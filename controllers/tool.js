import * as MongoDB from './mongo.js';
import * as ZaloAPI from './zalo.js';
import puppeteer from 'puppeteer';
import fs from 'fs';
import axios from 'axios';

function getStudyDate(startTerm, endTerm, weekday1, weekday2, absent1List, absent2List) {
    const convertWeekday = {
        'Ch·ªß nh·∫≠t': 0,
        'Th·ª© 2': 1,
        'Th·ª© 3': 2,
        'Th·ª© 4': 3,
        'Th·ª© 5': 4,
        'Th·ª© 6': 5,
        'Th·ª© 7': 6,
    };

    const date = new Date(startTerm.getTime());
    const dates = [];
    while (date <= endTerm) {
        if (date.getDay() === convertWeekday[weekday1] || date.getDay() === convertWeekday[weekday2]) {
            const formatDate = new Date(date).toLocaleDateString('vi-VN');

            dates.push(formatDate);
        }
        date.setDate(date.getDate() + 1);
    }

    const absent = `${absent1List},${absent2List}`
        .replace(/\s+/g, '')
        .split(',')
        .map((date) => {
            const [day, month, year] = date.split('/');
            return `${parseInt(day)}/${parseInt(month)}/${parseInt(year)}`;
        });

    const filteredDate = dates.filter((date) => !absent.includes(date));

    return filteredDate;
}

async function listStudentAttendance(studentId, currentTerm, studentInfoColl) {
    const pipeline = [
        {
            $match: {
                $and: [
                    {
                        studentId: parseInt(studentId),
                    },
                    {
                        'terms.term': parseInt(currentTerm),
                    },
                ],
            },
        },
        {
            $project: {
                _id: 0,
                studentName: 1,
                terms: {
                    $filter: {
                        input: '$terms',
                        as: 'item',
                        cond: {
                            $eq: ['$$item.term', parseInt(currentTerm)],
                        },
                    },
                },
            },
        },
    ];

    const aggCursorStudentAttendance = studentInfoColl.aggregate(pipeline);

    const resultStudentAttendance = await aggCursorStudentAttendance.toArray();

    if (resultStudentAttendance.length === 0) {
        return null;
    } else {
        return resultStudentAttendance;
    }
}

async function signUpRole(accessToken, zaloUserId) {
    const attachMessage = {
        text: `Vui l√≤ng ch·ªçn vai tr√≤ ƒëƒÉng k√≠:`,
        attachment: {
            type: 'template',
            payload: {
                buttons: [
                    {
                        title: 'T√¥i l√† ph·ª• huynh',
                        payload: '#dkph',
                        type: 'oa.query.show',
                    },
                    {
                        title: 'Con l√† h·ªçc sinh',
                        payload: '#dkhs',
                        type: 'oa.query.show',
                    },
                ],
            },
        },
    };

    await ZaloAPI.sendMessageWithButton(accessToken, zaloUserId, attachMessage);
}

async function signUpAlert(accessToken, zaloUserId, zaloColl) {
    // Check xem tai khoan da dang ki tren he thong chua
    const isRegister = await MongoDB.findOneUser(zaloColl, { zaloUserId: zaloUserId }, { projection: { _id: 0 } });

    // Neu dang ki roi thi hien thong bao cho PHHS
    if (isRegister.userPhone !== null) {
        const { displayName, userPhone, students } = isRegister;

        const studentRegister = students.map((v) => {
            const { zaloStudentId, zaloClassId, aliasName, role } = v;

            const studentName = aliasName.substring(3);

            return `${studentName} c√≥ ID l√† ${zaloStudentId}`;
        });

        const attachMessage = {
            text: `Zalo ${displayName} ƒë√£ ƒëƒÉng k√≠ s·ªë ${userPhone} v·ªõi h·ªçc sinh ${studentRegister.join(', ')}. 
Ph·ª• huynh c√≥ mu·ªën ƒëƒÉng k√≠ th√™m cho h·ªçc sinh kh√°c kh√¥ng?
(Nh·∫•n n√∫t b√™n d∆∞·ªõi ƒë·ªÉ x√°c nh·∫≠n)`,
            attachment: {
                type: 'template',
                payload: {
                    buttons: [
                        {
                            title: 'T√¥i mu·ªën ƒëƒÉng k√≠ th√™m cho h·ªçc sinh kh√°c',
                            payload: '#vtdk',
                            type: 'oa.query.show',
                        },
                    ],
                },
            },
        };

        await ZaloAPI.sendMessageWithButton(accessToken, zaloUserId, attachMessage);
    }
    // Neu chua thi hien thong bao chon vai tro dang ki
    else {
        await signUpRole(accessToken, zaloUserId);
    }
}

async function signUp4Parent(accessToken, zaloUserId) {
    const message = `üëâ ƒê·ªÉ x√°c nh·∫≠n ƒëƒÉng k√≠ t√†i kho·∫£n tr√™n Zalo n√†y, ph·ª• huynh h√£y nh·∫≠p theo ƒë√∫ng c√∫ ph√°p sau:
dkph IDHS SƒêT PH(ƒê√£ ƒëƒÉng k√≠)
---------------------------------------------
üëâ V√≠ d·ª•: 
dkph 2005xxx 0912345678
---------------------------------------------
üëâ Ch√∫ √Ω: 
- SƒêT trong c√∫ ph√°p ph·∫£i l√† SƒêT ƒë√£ ƒë∆∞·ª£c ƒëƒÉng k√≠ v·ªõi l·ªõp to√°n.
- T√†i kho·∫£n kh√¥ng nh·∫•t thi·∫øt ph·∫£i ƒë∆∞·ª£c ƒëƒÉng k√≠ b·∫±ng SƒêT ƒë√£ t·∫°o t√†i kho·∫£n Zalo.
- M·ªói t√†i kho·∫£n Zalo ch·ªâ ƒë∆∞·ª£c li√™n k·∫øt v·ªõi 1 SƒêT ƒë√£ ƒëƒÉng k√≠.`;

    await ZaloAPI.sendMessage(accessToken, zaloUserId, message);
}

async function signUp4Student(accessToken, zaloUserId) {
    const message = `üëâ ƒê·ªÉ x√°c nh·∫≠n ƒëƒÉng k√≠ t√†i kho·∫£n tr√™n Zalo n√†y, con h√£y nh·∫≠p theo ƒë√∫ng c√∫ ph√°p sau:
dkhs IDHS SƒêT HS (ƒê√£ ƒëƒÉng k√≠)
---------------------------------------------
üëâ V√≠ d·ª•: 
dkhs 2005xxx 0912345678
---------------------------------------------
üëâ Ch√∫ √Ω: 
- SƒêT trong c√∫ ph√°p ph·∫£i l√† SƒêT ƒë√£ ƒë∆∞·ª£c ƒëƒÉng k√≠ v·ªõi l·ªõp to√°n.
- T√†i kho·∫£n kh√¥ng nh·∫•t thi·∫øt ph·∫£i ƒë∆∞·ª£c ƒëƒÉng k√≠ b·∫±ng SƒêT ƒë√£ t·∫°o t√†i kho·∫£n Zalo.
- M·ªói t√†i kho·∫£n Zalo ch·ªâ ƒë∆∞·ª£c li√™n k·∫øt v·ªõi 1 SƒêT ƒë√£ ƒëƒÉng k√≠.`;

    await ZaloAPI.sendMessage(accessToken, zaloUserId, message);
}

async function notifyRegister(accessToken, zaloUserId, zaloColl) {
    const isExist = await MongoDB.findOneUser(zaloColl, { zaloUserId: zaloUserId }, { projection: { _id: 0 } });

    if (isExist === null) {
        const profileDoc = await ZaloAPI.getProfile(accessToken, zaloUserId);

        await ZaloAPI.removeFollowerFromTag(accessToken, zaloUserId, 'Ch∆∞a quan t√¢m');

        await ZaloAPI.tagFollower(accessToken, zaloUserId, 'Ch∆∞a ƒëƒÉng k√≠');

        await MongoDB.insertOneUser(zaloColl, profileDoc);
    }

    let studentArr = [];

    const { userPhone, students } = isExist;

    if (userPhone === null) {
        const attachMessage = {
            text: 'Ph·ª• huynh c·∫ßn ƒëƒÉng k√≠ t√†i kho·∫£n ƒë·ªÉ c√≥ th·ªÉ s·ª≠ d·ª•ng t√≠nh nƒÉng n√†y.',
            attachment: {
                type: 'template',
                payload: {
                    buttons: [
                        {
                            title: 'ƒêƒÉng k√≠ t√†i kho·∫£n',
                            payload: '#dktk',
                            type: 'oa.query.show',
                        },
                    ],
                },
            },
        };

        await ZaloAPI.sendMessageWithButton(accessToken, zaloUserId, attachMessage);

        return studentArr;
    } else {
        students.forEach((v) => {
            if (!v.zaloClassId.includes('N')) {
                studentArr.push([v.zaloStudentId, v.zaloClassId, v.role, v.aliasName]);
            }
        });

        if (studentArr.length === 0) {
            const goodByeMessage =
                'Hi·ªán t·∫°i ph·ª• huynh ƒëang kh√¥ng c√≥ con h·ªçc t·∫°i trung t√¢m. Ch√∫c ph·ª• huynh m·ªôt ng√†y t·ªët l√†nh!';

            await ZaloAPI.sendMessage(accessToken, zaloUserId, goodByeMessage);
        }

        return studentArr;
    }
}

async function sendClassInfo(accessToken, zaloUserId, classInfoColl, zaloColl) {
    const zaloStudentInfo = await notifyRegister(accessToken, zaloUserId, zaloColl);

    if (zaloStudentInfo.length === 0) {
        return;
    }

    for (let i = 0; i < zaloStudentInfo.length; i++) {
        const [zaloStudentId, zaloClassId, alisaName, role] = zaloStudentInfo[i];

        const classInfo = await MongoDB.findOneUser(
            classInfoColl,
            { classId: zaloClassId },
            { projection: { _id: 0 } }
        );

        const { className, room, currentTerm, totalDate, tuition, startTerm, endTerm, assistants, subjects } =
            classInfo;

        const assistantInfo = assistants
            .map((v) => {
                const { taName, taPhone, taZaloId } = v;

                return `Tr·ª£ gi·∫£ng: ${taName}\nƒêi·ªán tho·∫°i: ${taPhone}`;
            })
            .join(`\n`);

        const subjectInfo = subjects
            .map((v, i) => {
                const { name, teacher, day, start, end, absent } = v;

                return `${i + 1}) ${name}: ${teacher}\n- ${day}: ${start}-${end}`;
            })
            .join(`\n`);

        const message = `C√¢u l·∫°c b·ªô To√°n √Ånh S√°ng xin g·ª≠i th√¥ng tin l·ªõp ${className} nh∆∞ sau:
------------------------------   
Ph√≤ng h·ªçc: ${room}
------------------------------
${assistants.length ? assistantInfo : `Tr·ª£ gi·∫£ng:\nƒêi·ªán tho·∫°i:`}
------------------------------
Gi√°o vi√™n gi·∫£ng d·∫°y
${subjectInfo}
------------------------------
ƒê·ª£t hi·ªán t·∫°i: ${currentTerm}
T·ªïng s·ªë bu·ªïi: ${totalDate} bu·ªïi
B·∫Øt ƒë·∫ßu ƒë·ª£t: ${startTerm === null ? '' : startTerm}
K·∫øt th√∫c ƒë·ª£t: ${endTerm === null ? '' : endTerm}
------------------------------
H·ªçc ph√≠ m·ªói bu·ªïi: ${tuition}`;

        await ZaloAPI.sendMessage(accessToken, zaloUserId, message);
    }
}

async function sendScoreInfo(accessToken, zaloUserId, zaloColl, scoreInfoColl) {
    const zaloStudentInfo = await notifyRegister(accessToken, zaloUserId, zaloColl);

    if (zaloStudentInfo.length === 0) {
        return;
    }

    const currentDate = new Date();
    const currentMonth = currentDate.getUTCMonth();
    const currentYear = currentDate.getUTCFullYear();
    const startDate = new Date(Date.UTC(currentYear, currentMonth, 1));
    const endDate = new Date(Date.UTC(currentYear, currentMonth + 1, 1));

    zaloStudentInfo.forEach(async (v) => {
        const [zaloStudentId, zaloClassId, alisaName, role] = v;

        const studentName = alisaName.substring(3);
        let classNameZalo;

        const assignments = scoreInfoColl
            .find(
                {
                    deadline: {
                        $gte: new Date(startDate),
                        $lt: new Date(endDate),
                    },
                    classId: zaloClassId,
                },
                { projection: { _id: 0, uniqueHash: 0 } }
            )
            .sort({ deadline: -1 });

        // Step 1: Group by subjectName and deadline
        const groupedAssignments = {};

        let checkAverageAll = true;

        await assignments.forEach((assignment) => {
            const {
                deadline,
                delay,
                studentId,
                classId,
                className,
                studentName,
                correct,
                total,
                subjectDate,
                subject,
                status,
                subjectName,
            } = assignment;

            classNameZalo = className;

            if (zaloStudentId == studentId) {
                if (subjectDate !== 'ƒê·ªß' || status !== 'C≈©') {
                    checkAverageAll = false;
                }
            }

            const key = `${subjectName}-${subject}-${deadline}`;
            if (!groupedAssignments[key]) {
                groupedAssignments[key] = [];
            }
            groupedAssignments[key].push(assignment);
        });

        let zaloStudentRank = '';
        let zaloStudentScore = 0.0;
        if (checkAverageAll) {
            const studentTotals = {}; //will keep a sum of all scores for each student across assignments.
            const studentCounts = {}; // will keep a count of the number of assignments for each student.

            for (const key in groupedAssignments) {
                const group = groupedAssignments[key];
                group.forEach(({ studentId, correct, total, subjectDate, status }) => {
                    if (subjectDate !== 'ƒê·ªß' || status !== 'C≈©') {
                        return;
                    }

                    if (!(studentId in studentTotals)) {
                        studentTotals[studentId] = 0.0;
                        studentCounts[studentId] = 0;
                    }

                    const formatScore = correct === null ? 0.0 : (correct / total) * 10.0;

                    studentTotals[studentId] += formatScore;
                    studentCounts[studentId]++;
                });
            }

            const averages = [];
            for (const studentId in studentTotals) {
                console.log(studentId);
                console.log('studentTotals[studentId]: ' + studentTotals[studentId]);
                console.log('studentCounts[studentId]: ' + studentCounts[studentId]);

                averages.push({
                    studentId: parseInt(studentId),
                    average: Math.round((studentTotals[studentId] / studentCounts[studentId]) * 10) / 10,
                });
            }

            // Rank based on average scores:
            averages.sort((a, b) => b.average - a.average);

            console.log(averages);

            let rankAll = 1;
            let prevAverage = parseFloat(averages[0].average);
            const ranksAll = {};

            averages.forEach((avgObj, idx) => {
                if (avgObj.average !== prevAverage) {
                    rankAll = parseInt(idx + 1);
                }
                ranksAll[avgObj.studentId] = rankAll;
                prevAverage = avgObj.average;
            });

            zaloStudentRank = `Top ${ranksAll[zaloStudentId]}`;
            zaloStudentScore = averages.find((v) => v.studentId === zaloStudentId).average;
        }

        // Step 2 and 3: Compute scores and rank the students
        const rankingInfo = [];

        const convertDate = {
            CN: 0,
            T2: 1,
            T3: 2,
            T4: 3,
            T5: 4,
            T6: 5,
            T7: 6,
        };

        for (const key in groupedAssignments) {
            const group = groupedAssignments[key];

            const scores = group.map((ass) => {
                const { studentId, correct, total, subjectDate, deadline } = ass;
                const deadineDate = new Date(deadline);

                let formatScore;

                if (subjectDate !== 'ƒê·ªß' && deadineDate.getDay() !== convertDate[subjectDate]) {
                    formatScore = '';
                } else {
                    formatScore = correct === null ? 0.0 : (correct / total) * 10.0;
                }

                return {
                    studentId: studentId,
                    score: formatScore,
                };
            });

            scores.sort((a, b) => b.score - a.score);

            // Calculate rank
            let rank = 1;
            let prevScore = parseFloat(scores[0].score);
            const ranks = {};

            scores.forEach((scoreObj, idx) => {
                if (scoreObj.score !== prevScore) {
                    rank = parseInt(idx + 1);
                }
                ranks[scoreObj.studentId] = rank;
                prevScore = scoreObj.score;
            });

            const [subjectName, subject, deadline] = key.split('-');

            const deadineDate = new Date(deadline);
            const formatDeadline = `${deadineDate.getDate()}/${deadineDate.getMonth() + 1}`;

            rankingInfo.push({
                subjectName: subjectName,
                subject: subject,
                deadline: formatDeadline,
                scores,
                ranks,
            });
        }

        // Step 4: Convert to 2D format
        const results = [];

        rankingInfo.forEach((info) => {
            const { ranks, scores, deadline, subject, subjectName } = info;

            scores.forEach((scoreObj) => {
                const { studentId, score } = scoreObj;

                if (studentId === zaloStudentId) {
                    results.push([
                        deadline,
                        subject,
                        subjectName,
                        Math.round(score * 10) / 10,
                        `Top ${ranks[studentId]}`,
                    ]);
                }
            });
        });

        const jsonData = {
            className: classNameZalo,
            studentName: studentName,
            aveClassScore: Math.round(zaloStudentScore * 10) / 10,
            rankClass: zaloStudentRank,
            results: results,
            checkAverageAll: checkAverageAll,
        };

        const attachmentId = await captureTableFromJSON(jsonData, accessToken);

        const message = 'Trung t√¢m To√°n √Ånh S√°ng xin g·ª≠i k·∫øt qu·∫£ h·ªçc t·∫≠p c·ªßa con.';

        if (attachmentId) {
            await ZaloAPI.sendImageByAttachmentId(accessToken, zaloUserId, message, attachmentId);
        }

        // await ZaloAPI.sendMessage(accessToken, zaloUserId, message);
    });
}

async function generateTableHTML(className, studentName, aveClassScore, rankClass, results, checkAverageAll) {
    // Construct Header
    const date = new Date();
    const month = date.getMonth() + 1;
    const year = date.getFullYear();

    const extractRankClass = parseInt(rankClass.split(' ')[1]);
    let rankAllCss;

    if (extractRankClass <= 10) {
        rankAllCss = 'rank-good';
    } else if (extractRankClass <= 20) {
        rankAllCss = 'rank-normal';
    } else {
        rankAllCss = 'rank-bad';
    }

    const tableHTML = `
    <!DOCTYPE html>
<html lang="en">
    <head>
        <link rel="preconnect" href="https://fonts.gstatic.com">
        <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@400;500;600;700&display=swap" rel="stylesheet">
        <meta charset="UTF-8">

        <style>
            /* color variables */
            :root {
                --clr-primary: #81d4fa;
                --clr-primary-light: #e1f5fe;
                --clr-primary-dark: #4fc3f7;
                --clr-gray100: #f9fbff;
                --clr-gray150: #f4f6fb;
                --clr-gray200: #eef1f6;
                --clr-gray300: #e1e5ee;
                --clr-gray400: #767b91;
                --clr-gray500: #4f546c;
                --clr-gray600: #2a324b;
                --clr-gray700: #161d34;
                --clr-normal: #fff0c2;
                --clr-normal-font: #a68b00;
                --clr-bad: #ffcdd2;
                --clr-bad-font: #c62828;
                --clr-good: #c8e6c9;
                --clr-good-font: #388e3c;
                --clr-link: #2962ff;
                /* border radius */
                --radius: 0.2rem;
            }
    
            *,
            *::before,
            *::after {
                box-sizing: border-box;
                margin: 0;
                padding: 0;
            }
    
            body {
                font-family: Be Vietnam Pro, sans-serif;
                height: 100vh;
                display: flex;
                justify-content: center;
                align-items: center;
                color: var(--clr-gray500);
                font-size: 1rem;
                background-color: var(--clr-gray100);
                flex-direction: column;
            }

            .table-wrapper {
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            
            .table-section {
                margin-bottom: 2rem; /* Adjust this value to change space between two sections */
            }
    
            table {
                border-collapse: collapse;
                box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
                background-color: white;
                text-align: center;
                overflow: hidden;
            }

            .custom-table {
                width: 500px;
            }
    
            table thead {
                box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            }
    
            th {
                padding: 1rem 1.5rem;
                font-size: 1rem;
                font-weight: 600;
            }
    
            td {
                padding: 1rem 2rem;
            }
    
            .rank {
                display: inline-block;
                border-radius: var(--radius);
                padding: 0.4rem 1rem;
                text-align: center;
            }

            .rank-normal {
                background-color: var(--clr-normal);
                color: var(--clr-normal-font);
            }
    
            .rank-good {
                background-color: var(--clr-good);
                color: var(--clr-good-font);
            }
    
            .rank-bad {
                background-color: var(--clr-bad);
                color: var(--clr-bad-font);
            }

           
            /* Color alternating rows */
            tr:nth-child(even) {
                background-color: var(--clr-gray150);
            }

            .custom-header {
                font-weight: 600;
                color: #e11d48;
                font-size: 1.5rem;
                text-align: center;
                margin-bottom: 0.7rem;
                margin-top: 0.7rem;
            }
        </style>
    </head>
    
    <body>
        <div class="table-wrapper">
            <div class="table-section">${tableHeader}</div>

            <div class="table-section">
                ${detailedTableHeader}
                ${detailedTableRows}
                    </tbody>
                </table>
            </div>
        </div>
    </body>
</html>
    `;

    const tableHeader = !checkAverageAll
        ? ''
        : `
        <p class="custom-header">B·∫¢NG THEO D√ïI ƒêI·ªÇM HS L·ªöP ${className} T${month}/${year}</p>
        <table class="custom-table">
            <thead>
                <tr>
                    <th>T√™n h·ªçc sinh</th>
                    <th>ƒêi·ªÉm TB</th>
                    <th>X·∫øp h·∫°ng</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>${studentName}</td>
                    <td>${aveClassScore}</td>
                    <td><p class="rank ${rankAllCss}">${rankClass}</p></td>
                </tr>
            </tbody>
        </table>`;

    const formatDetail = checkAverageAll
        ? 'CHI TI·∫æT ƒêI·ªÇM S·ªê'
        : `CHI TI·∫æT ƒêI·ªÇM S·ªê HS ${studentName} L·ªöP ${className} T${month}/${year}`;

    // Construct detailed table
    const detailedTableHeader = `
        <p class="custom-header">${formatDetail}</p>
        <table>
            <thead>
                <tr>
                    <th>STT</th>
                    <th>H·∫°n n·ªôp</th>
                    <th>M√¥n h·ªçc</th>
                    <th>T√™n b√†i</th>
                    <th>ƒêi·ªÉm s·ªë</th>
                    <th>X·∫øp h·∫°ng</th>
                </tr>
            </thead>
            <tbody>`;

    let detailedTableRows = '';
    results.forEach((result, index) => {
        const [deadline, subject, subjectName, score, rank] = result;

        const extractRank = parseInt(rank.split(' ')[1]);
        let rankCss;

        if (extractRank <= 10) {
            rankCss = 'rank-good';
        } else if (extractRank <= 20) {
            rankCss = 'rank-normal';
        } else {
            rankCss = 'rank-bad';
        }

        detailedTableRows += `
            <tr>
                <td>${index + 1}</td>
                <td>${deadline}</td>
                <td>${subject}</td>
                <td>${subjectName}</td>
                <td>${score}</td>
                <td><p class="rank ${rankCss}">${rank}</p></td>
            </tr>`;
    });

    // Return full HTML
    return tableHTML;
}

async function captureTableFromJSON(jsonData, accessToken) {
    const { className, studentName, aveClassScore, rankClass, results, checkAverageAll } = jsonData;

    const browser = await puppeteer.launch({ headless: 'new' });
    const page = await browser.newPage();

    // Set viewport for high resolution
    await page.setViewport({
        width: 1000,
        height: 500 + results.length * 50,
        deviceScaleFactor: 3,
    });

    const tableHTML = await generateTableHTML(
        className,
        studentName,
        aveClassScore,
        rankClass,
        results,
        checkAverageAll
    );

    const uniqueId = `${Date.now()}_${Math.floor(Math.random() * 10000)}`;
    const htmlFileName = `temp_${uniqueId}.html`;
    const imageName = `table_${uniqueId}.png`;

    const imagePath = `${__dirname}/${imageName}`;
    const htmlFilePath = `${__dirname}/${htmlFileName}`;

    // Save the tableHTML to a temporary file

    fs.writeFileSync(htmlFilePath, tableHTML);

    // Load the HTML file using page.goto()
    await page.goto(`file://${htmlFilePath}`, { waitUntil: 'networkidle0' });

    await page.screenshot({ path: imagePath, fullPage: true });

    // Remove the temporary file
    fs.unlinkSync(htmlFilePath);

    await browser.close();

    // Upload the captured image
    const attachmentId = await uploadImageToZalo(accessToken, imagePath);

    if (attachmentId) {
        // If needed, remove the image after successful upload.
        fs.unlinkSync(imagePath);
    }
    return attachmentId;
}

async function uploadImageToZalo(accessToken, imagePath) {
    const formData = new FormData();
    formData.append('file', fs.createReadStream(imagePath));

    const config = {
        headers: {
            ...formData.getHeaders(),
            access_token: accessToken,
        },
    };

    try {
        const response = await axios.post('https://openapi.zalo.me/v2.0/oa/upload/image', formData, config);
        if (response.data.error === 0) {
            console.log('Image uploaded successfully!');
            return response.data.data.attachment_id;
        } else {
            console.error('Error uploading image:', response.data.message);
            return null;
        }
    } catch (error) {
        console.error('Failed to upload image:', error.message);
        return null;
    }
}

async function sendAssistantInfo(accessToken, zaloUserId, zaloColl, classInfoColl) {
    const zaloStudentInfo = await notifyRegister(accessToken, zaloUserId, zaloColl);

    if (zaloStudentInfo.length === 0) {
        return;
    }

    for (let i = 0; i < zaloStudentInfo.length; i++) {
        const [studentId, classId, role, aliasName] = zaloStudentInfo[i];

        const studentName = aliasName.slice(3);

        const { currentTerm, className, assistants } = await MongoDB.findOneUser(
            classInfoColl,
            { classId: classId },
            {
                projection: {
                    _id: 0,
                    currentTerm: 1,
                    className: 1,
                    assistants: 1,
                },
            }
        );

        if (assistants.length === 0) {
            const failContent = `Hi·ªán t·∫°i ch∆∞a c√≥ th√¥ng tin tr·ª£ gi·∫£ng c·ªßa con ${studentName} ${studentId} ·ªü l·ªõp ${className} ·∫°.`;

            await ZaloAPI.sendMessage(accessToken, zaloUserId, failContent);
        } else {
            const { taName, taPhone } = assistants[0];

            const successContent = `L·ªõp to√°n xin g·ª≠i ƒë·∫øn ${role.toLowerCase()} ${studentName} ·ªü l·ªõp ${className} s·ªë ƒëi·ªán tho·∫°i ch·ªã tr·ª£ gi·∫£ng ${taName} l√† ${taPhone}.\n\nL·ªõp to√°n c√≥ ch·ª©c nƒÉng t·ª± ƒë·ªông chuy·ªÉn ti·∫øp tin nh·∫Øn ƒë·∫øn t·ª´ng tr·ª£ gi·∫£ng qu·∫£n l√≠ l·ªõp n√™n tin nh·∫Øn s·∫Ω lu√¥n ƒë∆∞·ª£c tr·∫£ l·ªùi trong th·ªùi gian s·ªõm nh·∫•t. ${role} ch·ªâ n√™n li√™n h·ªá tr·ª£ gi·∫£ng trong tr∆∞·ªùng h·ª£p mu·ªën g·ªçi tr·ª±c ti·∫øp ·∫°!`;

            const attachMessage = {
                text: successContent,
                attachment: {
                    type: 'template',
                    payload: {
                        buttons: [
                            {
                                title: `Nh·∫Øn tin ƒë·∫øn tr·ª£ gi·∫£ng ${taName}`,
                                type: 'oa.open.sms',
                                payload: {
                                    content: `Ch√†o ${taName}, t√¥i l√† ${role.toLowerCase()} ${studentName} ·ªü l·ªõp ${className}`,
                                    phone_code: taPhone,
                                },
                            },
                            {
                                title: `G·ªçi ƒëi·ªán ƒë·∫øn tr·ª£ gi·∫£ng ${taName}`,
                                type: 'oa.open.phone',
                                payload: {
                                    phone_code: taPhone,
                                },
                            },
                        ],
                    },
                },
            };

            await ZaloAPI.sendMessageWithButton(accessToken, zaloUserId, attachMessage);
        }
    }
}

async function sendAttendanceInfo(accessToken, zaloUserId, zaloColl, classInfoColl, studentInfoColl) {
    const zaloStudentInfo = await notifyRegister(accessToken, zaloUserId, zaloColl);

    if (zaloStudentInfo.length === 0) {
        return;
    }

    for (let i = 0; i < zaloStudentInfo.length; i++) {
        const [studentId, classId, role, aliasName] = zaloStudentInfo[i];

        const studentName = aliasName.slice(3);

        const { currentTerm, className } = await MongoDB.findOneUser(
            classInfoColl,
            { classId: classId },
            { projection: { _id: 0, currentTerm: 1, className: 1 } }
        );

        const studentTermInfo = await listStudentAttendance(studentId, currentTerm, studentInfoColl);

        if (studentTermInfo === null) {
            const failContent = `D·ªØ li·ªáu ƒëi·ªÉm danh ƒë·ª£t ${currentTerm} c·ªßa h·ªçc sinh ${studentName} ${studentId} l·ªõp ${className} ch∆∞a c√≥ tr√™n c∆° s·ªü d·ªØ li·ªáu. ${role} vui l√≤ng li√™n h·ªá v·ªõi tr·ª£ gi·∫£ng ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£.`;

            await ZaloAPI.sendMessage(accessToken, zaloUserId, failContent);

            continue;
        }

        const { terms } = studentTermInfo[0];

        const {
            term, // dot hien tai
            start, // bat dau dot
            end, // ket thuc dot
            total, // so buoi trong dot
            study, // so buoi hoc
            absent, // so buoi nghi
            subject, // mon hoc
            remainderBefore, // du dot truoc
            billing, // phai nop
            payment, // da nop
            type, // hinh thuc nop
            paidDate, // ngay nop
            remainder, // con thua
            attendances,
            absences,
        } = terms[0];

        const attendanceInfo = attendances.map((v) => {
            const { no, newDate, teacher } = v;

            const beautifyDate = formatDate(newDate);

            return `- ${no}: ${teacher} - ${beautifyDate}`;
        });

        const absenceInfo = absences.map((v) => {
            const { no, newDate, teacher } = v;

            const beautifyDate = formatDate(newDate);

            return `- ${no}: ${teacher} - ${beautifyDate}`;
        });

        const message = `C√¢u l·∫°c b·ªô To√°n √Ånh S√°ng xin g·ª≠i ƒë·∫øn ${role.toLowerCase()} ${studentName} ${studentId} l·ªõp ${className} k·∫øt qu·∫£ chuy√™n c·∫ßn ƒë·ª£t ${term} nh∆∞ sau:
------------------------
T·ªïng s·ªë bu·ªïi ƒë·ª£t ${term}: ${total} bu·ªïi
------------------------
S·ªë bu·ªïi ƒë√£ h·ªçc: ${study} bu·ªïi${attendanceInfo.length ? `\n${attendanceInfo.join(`\n`)}` : ''}
------------------------
S·ªë bu·ªïi ƒë√£ ngh·ªâ: ${absent} bu·ªïi${absenceInfo.length ? `\n${absenceInfo.join(`\n`)}` : ''}`;

        await ZaloAPI.sendMessage(accessToken, zaloUserId, message);
    }
}

async function sendSyntaxPayment(accessToken, zaloUserId, zaloColl, classInfoColl) {
    const zaloStudentInfo = await notifyRegister(accessToken, zaloUserId, zaloColl);

    if (zaloStudentInfo.length === 0) {
        return;
    }

    for (let i = 0; i < zaloStudentInfo.length; i++) {
        const [studentId, classId, role, alisaName] = zaloStudentInfo[i];

        const studentName = alisaName.substring(3);

        const { currentTerm, className } = await MongoDB.findOneUser(
            classInfoColl,
            { classId: classId },
            { projection: { _id: 0, currentTerm: 1, className: 1 } }
        );

        const syntaxPayment = `${removeVietNam(studentName)} ${studentId} HPD${currentTerm}`;

        await ZaloAPI.sendMessage(accessToken, zaloUserId, syntaxPayment);
    }
}

async function sendPaymentTypeInfo(accessToken, zaloUserId, zaloColl, classInfoColl, studentInfoColl) {
    const zaloStudentInfo = await notifyRegister(accessToken, zaloUserId, zaloColl);

    if (zaloStudentInfo.length === 0) {
        return;
    }

    for (let i = 0; i < zaloStudentInfo.length; i++) {
        const [studentId, classId, role, aliasName] = zaloStudentInfo[i];
        const studentName = aliasName.slice(3);

        const { currentTerm, className } = await MongoDB.findOneUser(
            classInfoColl,
            { classId: classId },
            { projection: { _id: 0, currentTerm: 1, className: 1 } }
        );

        const studentTermInfo = await listStudentAttendance(studentId, currentTerm, studentInfoColl);
        const { terms } = studentTermInfo[0];
        const { billing, payment } = terms[0];

        // Truong hop phu huynh chua chuyen khoan
        if (payment !== null || payment < billing || billing.includes('Th·ª´a') || billing.includes('ƒê√£ n·ªôp ƒë·ªß')) {
            const syntaxPayment = `${removeVietNam(studentName)} ${studentId} HPD${currentTerm}`;

            const attachMessage = {
                text: `Ph·ª• huynh c√≥ 3 h√¨nh th·ª©c n·ªôp h·ªçc ph√≠ ƒë·ª£t ${currentTerm} cho h·ªçc sinh ${studentName} ${studentId} l·ªõp ${className} bao g·ªìm:
-------
1) H·ªçc sinh n·ªôp ti·ªÅn m·∫∑t tr·ª±c ti·∫øp t·∫°i l·ªõp to√°n cho tr·ª£ gi·∫£ng v√† nh·∫≠n bi√™n lai v·ªÅ.

2) Ph·ª• huynh chuy·ªÉn kho·∫£n v√†o t√†i kho·∫£n ƒê·∫∑ng Th·ªã H∆∞·ªùng ‚Äì ng√¢n h√†ng VietinBank, s·ªë: 107004444793. Trong n·ªôi dung chuy·ªÉn kho·∫£n c·∫ßn ph·∫£i ghi ƒë√∫ng n·ªôi dung sau ƒë·ªÉ h·ªá th·ªëng c·∫≠p nh·∫≠t t·ª± ƒë·ªông:
${syntaxPayment}

3) Ph·ª• huynh qu√©t m√£ QR code ph√≠a b√™n d∆∞·ªõi ƒë·ªÉ chuy·ªÉn kho·∫£n.
-------
* L∆∞u √Ω: 
- Sau khi chuy·ªÉn kho·∫£n th√†nh c√¥ng, ph·ª• huynh ch·ª•p m√†n h√¨nh ·∫£nh bi√™n lai chuy·ªÉn kho·∫£n v√†o l·∫°i trang Zalo OA c·ªßa l·ªõp to√°n.
- N·∫øu ph·ª• huynh ƒëƒÉng k√≠ t·ª´ 2 con tr·ªü l√™n vui l√≤ng chuy·ªÉn kho·∫£n ri√™ng cho t·ª´ng con ·∫°.`,

                attachment: {
                    type: 'template',
                    payload: {
                        buttons: [
                            {
                                title: 'Sao ch√©p c√∫ ph√°p chuy·ªÉn kho·∫£n',
                                payload: '#cpck',
                                type: 'oa.query.show',
                            },
                        ],
                    },
                },
            };

            await ZaloAPI.sendMessageWithButton(accessToken, zaloUserId, attachMessage);

            // Gui ma QR code cho phu huynh
            const qrCodeContent = `Ph·ª• huynh qu√©t m√£ QR code tr√™n ƒë·ªÉ thanh to√°n h·ªçc ph√≠ ƒë·ª£t ${currentTerm} cho con ${studentName}.`;
            const qrCodeUrl = createQRCodePayment(billing, syntaxPayment);

            await ZaloAPI.sendImageByUrl(accessToken, zaloUserId, qrCodeContent, qrCodeUrl);
        }
        // Truong hop phu huynh da chuyen khoan
        else {
            const doneContent = `Ph·ª• huynh ƒë√£ ho√†n th√†nh h·ªçc ph√≠ ƒë·ª£t ${currentTerm} cho con ${studentName} r·ªìi ·∫°!`;

            await ZaloAPI.sendMessage(accessToken, zaloUserId, doneContent);
        }
    }
}

function createQRCodePayment(amount, content) {
    const BANK_ID = 'vietinbank';
    const ACCOUNT_NO = 107004444793;
    const TEMPLATE = 'cJHMwH';
    const ACCOUNT_NAME = encodeURIComponent('Dang Thi Huong');
    const CONTENT = encodeURIComponent(content);

    const qrCodeUrl = `https://img.vietqr.io/image/${BANK_ID}-${ACCOUNT_NO}-${TEMPLATE}.png?amount=${amount}&addInfo=${CONTENT}&accountName=${ACCOUNT_NAME}`;
    return qrCodeUrl;
}

async function sendPaymentInfo(accessToken, zaloUserId, zaloColl, classInfoColl, studentInfoColl) {
    const zaloStudentInfo = await notifyRegister(accessToken, zaloUserId, zaloColl);

    if (zaloStudentInfo.length === 0) {
        return;
    }

    for (let i = 0; i < zaloStudentInfo.length; i++) {
        const [studentId, classId, role, aliasName] = zaloStudentInfo[i];

        const studentName = aliasName.slice(3);

        const { currentTerm, className } = await MongoDB.findOneUser(
            classInfoColl,
            { classId: classId },
            { projection: { _id: 0, currentTerm: 1, className: 1 } }
        );

        const studentTermInfo = await listStudentAttendance(studentId, currentTerm, studentInfoColl);

        if (studentTermInfo === null) {
            const failContent = `D·ªØ li·ªáu h·ªçc ph√≠ ƒë·ª£t ${currentTerm} c·ªßa h·ªçc sinh ${studentName} ${studentId} l·ªõp ${className} ch∆∞a c√≥ tr√™n c∆° s·ªü d·ªØ li·ªáu. ${role} vui l√≤ng li√™n h·ªá v·ªõi tr·ª£ gi·∫£ng ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£.`;

            await ZaloAPI.sendMessage(accessToken, zaloUserId, failContent);

            continue;
        }

        const { terms } = studentTermInfo[0];

        const {
            term, // dot hien tai
            start, // bat dau dot
            end, // ket thuc dot
            total, // so buoi trong dot
            study, // so buoi hoc
            absent, // so buoi nghi
            subject, // mon hoc
            remainderBefore, // du dot truoc
            billing, // phai nop
            payment, // da nop
            type, // hinh thuc nop
            paidDate, // ngay nop
            remainder, // con thua
            attendances,
            absences,
        } = terms[0];

        const formatBilling = billing === null ? 'ch∆∞a c√≥' : typeof billing === 'string' ? '' : formatCurrency(billing);

        let formatStatus;

        if (typeof billing === 'string' && billing.includes('ƒê√£')) {
            formatStatus = 'ƒê√≥ng ƒë·ªß ‚úÖ';
        } else {
            if (payment !== null) {
                if (payment > billing) {
                    formatStatus = `th·ª´a ${formatCurrency(payment - billing)} üîî`;
                } else if (payment < billing) {
                    formatStatus = `thi·∫øu ${formatCurrency(billing - payment)} ‚ùå`;
                } else {
                    formatStatus = 'ƒê√≥ng ƒë·ªß ‚úÖ';
                }
            } else if (payment === null && typeof billing === 'string' && billing.includes('Th·ª´a')) {
                formatStatus = billing.toLowerCase() + ' üîî';
            } else {
                formatStatus = 'Ch∆∞a ƒë√≥ng ‚ùå';
            }
        }

        const formatRemainder =
            remainder >= 0 ? `th·ª´a ${formatCurrency(remainderBefore)}` : `thi·∫øu ${formatCurrency(remainderBefore)}`;

        const isPaid = payment !== null;

        const isPaidWithScholarship =
            payment === null && typeof billing === 'string' && (billing.includes('ƒê√£') || billing.includes('Th·ª´a'));

        const formatPaid = isPaid
            ? `\n------------------------------------------
H·ªçc ph√≠ ƒë√£ n·ªôp: ${formatCurrency(payment)}
H√¨nh th·ª©c n·ªôp: ${type}
Ng√†y n·ªôp: ${paidDate}
${remainder >= 0 ? `H·ªçc ph√≠ th·ª´a ƒë·ª£t ${term}: ` : `H·ªçc ph√≠ thi·∫øu ${term}: `}${formatCurrency(remainder)}`
            : '';

        const attachMessageWithButton = {
            text: `C√¢u l·∫°c b·ªô To√°n √Ånh S√°ng xin g·ª≠i ƒë·∫øn ${role.toLowerCase()} ${studentName} ${studentId} l·ªõp ${className} t√¨nh tr·∫°ng h·ªçc ph√≠ ƒë·ª£t ${term} nh∆∞ sau:
------------------------------------------
B·∫Øt ƒë·∫ßu ƒë·ª£t: ${formatDate(start)}
K·∫øt th√∫c ƒë·ª£t: ${formatDate(end)}
------------------------------------------
Bu·ªïi h·ªçc: ${subject}
T·ªïng s·ªë bu·ªïi trong ƒë·ª£t: ${total} bu·ªïi
S·ªë bu·ªïi ƒë√£ h·ªçc: ${study} bu·ªïi
S·ªë bu·ªïi v·∫Øng m·∫∑t: ${absent} bu·ªïi
------------------------------------------
H·ªçc ph√≠ ƒë·ª£t tr∆∞·ªõc: ${formatRemainder}    
H·ªçc ph√≠ ph·∫£i n·ªôp: ${formatBilling}
T√¨nh tr·∫°ng: ${formatStatus}${formatPaid}
------------------------------------------
Ch√∫ √Ω: s·ªë bu·ªïi ƒë√£ h·ªçc, v·∫Øng m·∫∑t v√† h·ªçc ph√≠ c√≤n th·ª´a s·∫Ω t·ª± ƒë·ªông ƒë∆∞·ª£c c·∫≠p nh·∫≠t sau m·ªói bu·ªïi h·ªçc.`,
            attachment: {
                type: 'template',
                payload: {
                    buttons: [
                        {
                            title: 'Th√¥ng tin chuy·ªÉn kho·∫£n',
                            payload: '#ttck',
                            type: 'oa.query.show',
                        },
                        {
                            title: 'C√∫ ph√°p chuy·ªÉn kho·∫£n',
                            payload: '#cpck',
                            type: 'oa.query.show',
                        },
                    ],
                },
            },
        };

        const simpleMessage = `C√¢u l·∫°c b·ªô To√°n √Ånh S√°ng xin g·ª≠i ƒë·∫øn ${role.toLowerCase()} ${studentName} ${studentId} l·ªõp ${className} t√¨nh tr·∫°ng h·ªçc ph√≠ ƒë·ª£t ${term} nh∆∞ sau:
------------------------------------------
B·∫Øt ƒë·∫ßu ƒë·ª£t: ${formatDate(start)}
K·∫øt th√∫c ƒë·ª£t: ${formatDate(end)}
------------------------------------------
Bu·ªïi h·ªçc: ${subject}
T·ªïng s·ªë bu·ªïi trong ƒë·ª£t: ${total} bu·ªïi
S·ªë bu·ªïi ƒë√£ h·ªçc: ${study} bu·ªïi
S·ªë bu·ªïi v·∫Øng m·∫∑t: ${absent} bu·ªïi
------------------------------------------
H·ªçc ph√≠ ƒë·ª£t tr∆∞·ªõc: ${formatRemainder}    
H·ªçc ph√≠ ph·∫£i n·ªôp: ${formatBilling}
T√¨nh tr·∫°ng: ${formatStatus}${formatPaid}
------------------------------------------
Ch√∫ √Ω: s·ªë bu·ªïi ƒë√£ h·ªçc, v·∫Øng m·∫∑t v√† h·ªçc ph√≠ c√≤n th·ª´a s·∫Ω t·ª± ƒë·ªông ƒë∆∞·ª£c c·∫≠p nh·∫≠t sau m·ªói bu·ªïi h·ªçc.`;
        if (isPaid || isPaidWithScholarship) {
            await ZaloAPI.sendMessage(accessToken, zaloUserId, simpleMessage);
        } else {
            await ZaloAPI.sendMessageWithButton(accessToken, zaloUserId, attachMessageWithButton);
        }
    }
}

function removeVietNam(str) {
    return str
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/ƒë/g, 'd')
        .replace(/ƒê/g, 'D');
}

function formatDate(dateStr) {
    const date = new Date(dateStr);

    return date.toLocaleDateString('vi-VN');
}

function formatDateTime(dateStr) {
    const newDate = new Date(dateStr);

    const options = {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
    };

    return newDate.toLocaleString('vi-VN', options);
}

function formatCurrency(money) {
    return `${Math.abs(money).toLocaleString('vi-VN')} ƒë`;
}

function nomarlizeSyntax(str) {
    return str
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/ƒë/g, 'd')
        .replace(/ƒê/g, 'D')
        .toLowerCase()
        .replace(/\s+/g, '');
}

function createDate(dateStr) {
    const [day, month, year] = dateStr.split('/');

    return new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
}

async function findZaloIdFromStudentId(zaloColl, zaloStudentId, role) {
    const cursor = zaloColl.find(
        {
            'students.zaloStudentId': parseInt(zaloStudentId),
            'students.role': role,
        },
        { projection: { _id: 0, zaloUserId: 1, 'students.$': 1 } }
    );

    let zaloIdArr = [];
    await cursor.forEach((v) => {
        zaloIdArr.push([v.zaloUserId, v.students[0].zaloClassId]);
    });
    // Do la classId nen khong thanh van de vi neu co truong hop ca 2 hs khac ID thi do $ match ket qua dau tien dung nen van duoc

    return zaloIdArr;
}

async function sendMessage2Assistant(accessToken, classInfoColl, classId, forwardContent) {
    const result = await MongoDB.findOneUser(
        classInfoColl,
        { classId: classId },
        { projection: { _id: 0, assistants: 1 } }
    );

    const isExistAssistant = result !== null;

    if (isExistAssistant) {
        const { assistants } = result;

        for (let i = 0; i < assistants.length; i++) {
            const assistant = assistants[i];
            const { taZaloId } = assistant;

            await ZaloAPI.sendMessage(accessToken, taZaloId, forwardContent);
        }
    }
}

async function sendResponse2Client(accessToken, zaloUserId, messageId, responseContent, action) {
    ZaloAPI.sendReaction(accessToken, zaloUserId, messageId, action);

    await ZaloAPI.sendMessage(accessToken, zaloUserId, responseContent);
}

async function getContentFromMsgId(accessToken, zaloUserId, messageId) {
    const conversation = await ZaloAPI.getConversation(accessToken, zaloUserId);

    if (conversation !== undefined) {
        for (let i = 0; i < conversation.length; i++) {
            const { message_id, message } = conversation[i];

            if (message_id === messageId) {
                return message;
            }
        }
    } else {
        return undefined;
    }
}

async function sendUnfollow2Assistant(accessToken, zaloUserId, zaloColl, classInfoColl) {
    const parentInfo = await MongoDB.findOneUser(zaloColl, { zaloUserId: zaloUserId }, { projection: { _id: 0 } });

    if (parentInfo != null) {
        await ZaloAPI.removeFollowerFromTag(accessToken, zaloUserId, 'Ch∆∞a ƒëƒÉng k√≠');

        await ZaloAPI.tagFollower(accessToken, zaloUserId, 'Ch∆∞a quan t√¢m');

        MongoDB.updateOneUser(zaloColl, { zaloUserId: `${zaloUserId}` }, { $set: { status: 'unfollow' } });

        const { students, displayName } = parentInfo;

        for (let i = 0; i < students.length; i++) {
            const { zaloStudentId, zaloClassId, aliasName } = students[i];

            const assistantInfo = await MongoDB.findOneUser(
                classInfoColl,
                { classId: zaloClassId },
                { projection: { _id: 0, assistants: 1 } }
            );

            if (assistantInfo !== null) {
                const { assistants } = assistantInfo;

                for (let j = 0; j < assistants.length; j++) {
                    const { taZaloId } = assistants[j];

                    const unfollowContent = `${aliasName} (${zaloStudentId}) v·ªõi t√™n Zalo ${displayName} ƒë√£ h·ªßy theo d√µi OA.\n\nTr·ª£ gi·∫£ng h√£y ki·ªÉm tra nguy√™n nh√¢n.`;

                    await ZaloAPI.sendMessage(accessToken, taZaloId, unfollowContent);
                }
            }
        }
    }
}

async function sendReactBack2Parent(accessToken, zaloUserId, messageId, reactIcon, zaloColl) {
    const content = await getContentFromMsgId(accessToken, zaloUserId, messageId);

    if (content !== undefined) {
        const [UID, MID] = content.split('\n\n').at(-1).split(`\n`);

        const zaloId = await findZaloIdFromUserPhone(zaloColl, UID.split(' ')[1]);
        const zaloMessageId = MID.split(' ')[1];

        if (zaloId !== null) {
            await ZaloAPI.sendReaction(accessToken, zaloId, zaloMessageId, reactIcon);
        }
    }
}

async function sendImageBack2Parent(accessToken, imageInfo, zaloColl) {
    // Kiem tra noi dung anh co chua noi dung khong
    const isContainPhoneNum = imageInfo.hasOwnProperty('text');

    // Kiem tra xem co chua so dien thoai khong
    if (isContainPhoneNum) {
        const isValidPhone = imageInfo.text.length === 10;

        if (isValidPhone) {
            const { attachments, text: userPhone } = imageInfo;

            const imageUrl = attachments[0].payload.url;

            const zaloUserId = await findZaloIdFromUserPhone(zaloColl, userPhone);

            await ZaloAPI.sendImageByUrl(accessToken, zaloUserId, '', imageUrl);
        }
    }
}

async function findZaloIdFromUserPhone(zaloColl, userPhone) {
    const result = await MongoDB.findOneUser(
        zaloColl,
        { userPhone: userPhone },
        { projection: { _id: 0, zaloUserId: 1 } }
    );

    if (result !== null) {
        return result.zaloUserId;
    } else {
        return null;
    }
}

async function sendMessageBack2Parent(accessToken, zaloUserId, replyContent, quoteMessageId, zaloColl) {
    const conversation = await ZaloAPI.getConversation(accessToken, zaloUserId);

    for (let i = 0; i < conversation.length; i++) {
        const { message_id, message } = conversation[i];

        if (typeof message === 'string') {
            if (message_id === quoteMessageId) {
                const [UID, MID] = message.split('\n\n').at(-1).split(`\n`);

                const zaloId = await findZaloIdFromUserPhone(zaloColl, UID.split(' ')[1]);
                const zaloMessageId = MID.split(' ')[1];

                await ZaloAPI.sendMessage(accessToken, zaloId, replyContent);

                break; // Chi can tim thay ID tin nhan la huy vong lap luon
            }
        }
    }
}

async function sendImage2Assistant(res, accessToken, classInfoColl, zaloClassId, attachments, forwardImageContent) {
    const imageUrl = attachments[0].payload.url;

    const { assistants } = await MongoDB.findOneUser(
        classInfoColl,
        { classId: zaloClassId },
        { projection: { _id: 0, assistants: 1 } }
    );

    for (let i = 0; i < assistants.length; i++) {
        const assistant = assistants[i];
        const { taZaloId } = assistant;

        await ZaloAPI.sendImageByUrl(accessToken, taZaloId, forwardImageContent, imageUrl);
    }
}

async function forwardImage2Assistant(res, accessToken, zaloUserId, zaloColl, classInfoColl, imageInfo) {
    const isRegister = await MongoDB.findOneUser(
        zaloColl,
        { zaloUserId: `${zaloUserId}` },
        { projection: { _id: 0, students: 1, userPhone: 1, displayName: 1 } }
    );

    // PHHS chua dang ki tai khoan thi khong nhan lai
    if (isRegister.students.length === 0) {
        return;
    }
    // PHHS da dang ki tai khoan thi chuyen tiep toi tro giang
    else {
        const { attachments, text: content, msg_id: messageId } = imageInfo;
        const { userPhone, displayName } = isRegister;

        // Vong lap vi co truong hop 1 tai khoan Zalo dki 2 HS
        for (let i = 0; i < isRegister.students.length; i++) {
            const { zaloStudentId, zaloClassId, aliasName } = isRegister.students[i];

            // chuyen tiep tin nhan den tro giang tuong ung
            const forwardImageContent = `${aliasName} (${displayName}) ${zaloStudentId} l·ªõp ${zaloClassId} ƒë√£ g·ª≠i ·∫£nh${
                content === undefined ? ':' : ` v·ªõi n·ªôi dung: ${content}.`
            }\n\nUID: ${userPhone}`;

            await sendImage2Assistant(res, accessToken, classInfoColl, zaloClassId, attachments, forwardImageContent);
        }
    }
}

async function forwardMessage2Assistant(accessToken, zaloUserId, messageId, zaloColl, classInfoColl, content) {
    const zaloInfo = await MongoDB.findOneUser(zaloColl, { zaloUserId: `${zaloUserId}` }, { projection: { _id: 0 } });

    const isExist = zaloInfo !== null;

    if (isExist) {
        const isRegister = zaloInfo.students.length !== 0;

        // PHHS da dang ki tai khoan
        if (isRegister) {
            const { userPhone, displayName } = zaloInfo;

            const totalStudent = zaloInfo.students.length;

            for (let i = 0; i < totalStudent; i++) {
                // Vong lap vi co truong hop 1 tai khoan Zalo dki 2 HS
                const { zaloStudentId, zaloClassId, aliasName } = zaloInfo.students[i];

                // chuyen tiep tin nhan den tro giang tuong ung
                const forwardContent = `${aliasName} (${displayName}) ${zaloStudentId} l·ªõp ${zaloClassId} ƒë√£ g·ª≠i tin:\n${content}\n\nUID: ${userPhone}\nMID: ${messageId}`;

                await sendMessage2Assistant(accessToken, classInfoColl, zaloClassId, forwardContent);
            }
        }
    }
}

async function isManagerCheck(zaloUserId, classInfoColl) {
    const result = await MongoDB.findOneUser(
        classInfoColl,
        { 'assistants.taZaloId': zaloUserId },
        { projection: { _id: 0 } }
    );

    return result === null ? false : true;
}

async function isFollow(zaloUserId, accessToken) {
    const response = await ZaloAPI.getProfile(accessToken, zaloUserId);

    return response ? true : false;
}

async function signUp4Assistant(res, accessToken, taZaloId, classInfoColl, zaloColl, content, messageId) {
    // dktg 2009A0 0915806944 Tr·ªçng Linh
    if (content.length < 24) {
        const failContent = `‚ùå ƒêƒÉng k√≠ th·∫•t b·∫°i!\n\nC√∫ ph√°p kh√¥ng ƒë√∫ng. Tr·ª£ gi·∫£ng h√£y nh·∫≠p l·∫°i.`;
        sendResponse2Client(res, accessToken, taZaloId, messageId, failContent, 'sad');
        return;
    }

    const [syntax, classId, taPhone, ...splitName] = content.split(' ');

    const taName = splitName.join(' ').replace(/\s+/g, ' ').trim();

    // check xem da co tro giang tren he thong chua
    const isAssistantExist = await MongoDB.findOneUser(
        classInfoColl,
        { 'assistants.taPhone': taPhone, classId: classId },
        { projection: { _id: 0, assistants: 1 } }
    );

    // Neu chua ton tai thi tao moi

    if (isAssistantExist === null) {
        // Cap nhat tag tren Zalo OA Chat
        await ZaloAPI.tagFollower(accessToken, taZaloId, 'Tr·ª£ gi·∫£ng');
        await ZaloAPI.tagFollower(accessToken, taZaloId, classId);

        await MongoDB.updateOneUser(
            classInfoColl,
            { classId: classId },
            {
                $push: {
                    assistants: {
                        taName: taName,
                        taPhone: taPhone,
                        taZaloId: taZaloId,
                    },
                },
            }
        );

        MongoDB.updateOneUser(zaloColl, { zaloUserId: taZaloId }, { $set: { userPhone: taPhone } });

        const successContent = `‚úÖ ƒêƒÉng k√≠ th√†nh c√¥ng cho tr·ª£ gi·∫£ng ${taName} v·ªõi m√£ l·ªõp ${classId} v√† s·ªë ƒëi·ªán tho·∫°i ${taPhone}.`;

        await sendResponse2Client(accessToken, taZaloId, messageId, successContent, 'heart');

        await ZaloAPI.removeFollowerFromTag(accessToken, taZaloId, 'Ch∆∞a ƒëƒÉng k√≠');
    } else {
        // Neu ton tai roi thi:

        const failContent = `‚ùå ƒêƒÉng k√≠ th·∫•t b·∫°i v√¨ tr·ª£ gi·∫£ng ${taName} ƒë√£ li√™n k·∫øt v·ªõi m√£ l·ªõp ${classId}.`;

        await sendResponse2Client(accessToken, taZaloId, messageId, failContent, 'sad');
    }
}

async function deleteAccount(formatContent, accessToken, taZaloId, zaloColl, classInfoColl, messageId, zaloRole) {
    // Check xem co phai do Tro giang nhan khong
    const isManager = await isManagerCheck(taZaloId, classInfoColl);

    // Neu tu tro giang
    if (isManager) {
        const TOTAL_DELETE_SYNTAX = 20;
        const isValidDeleteSyntax = formatContent.length === TOTAL_DELETE_SYNTAX;

        // Neu cu phap dung
        if (isValidDeleteSyntax) {
            const targetStudentId = parseInt(formatContent.substring(3, 10));
            const registerPhone = formatContent.slice(-10);

            // Xoa tag va thong tin tren Zalo OA chat

            const cursor = zaloColl.find(
                {
                    'students.zaloStudentId': targetStudentId,
                    userPhone: registerPhone,
                },
                { projection: { _id: 0 } }
            );

            const documents = await cursor.toArray();
            for (const v of documents) {
                const { zaloUserId, students, displayName } = v;

                // Xoa tag lop hoc
                for (let i = 0; i < students.length; i++) {
                    const removeTag = students[i].zaloClassId;

                    await ZaloAPI.removeFollowerFromTag(accessToken, zaloUserId, removeTag);
                }

                // Xoa tag Phu huynh/Hoc sinh
                ZaloAPI.removeFollowerFromTag(accessToken, zaloUserId, zaloRole);
                ZaloAPI.tagFollower(accessToken, zaloUserId, 'Ch∆∞a ƒëƒÉng k√≠');

                // Xoa dang ki tai khoan trong Zalo Coll
                MongoDB.updateOneUser(
                    zaloColl,
                    { userPhone: registerPhone, 'students.zaloStudentId': targetStudentId },
                    { $set: { userPhone: null, students: [] } }
                );

                // Gui xac nhan den PHHS
                const sendResponse2DeleteUser = `Tr·ª£ gi·∫£ng ƒë√£ xo√° s·ªë ƒëi·ªán tho·∫°i ${registerPhone} ƒë∆∞·ª£c ƒëƒÉng k√≠ v·ªõi h·ªçc sinh ${targetStudentId} tr√™n Zalo ${displayName}.`;

                await ZaloAPI.sendMessage(accessToken, zaloUserId, sendResponse2DeleteUser);

                // Gui xac nhan den Tro giang
                const successContent = `üóëÔ∏è Xo√° th√†nh c√¥ng s·ªë ƒëi·ªán tho·∫°i ${registerPhone} ƒë∆∞·ª£c ƒëƒÉng k√≠ v·ªõi h·ªçc sinh ${targetStudentId} tr√™n Zalo ${displayName}.`;

                await ZaloAPI.sendReaction(accessToken, taZaloId, messageId, 'heart');

                await ZaloAPI.sendMessage(accessToken, taZaloId, successContent);
            }
        }

        // Neu cu phap sai
        else {
            const failContent = `‚ùå ƒêƒÉng k√≠ th·∫•t b·∫°i!\n\nC√∫ ph√°p kh√¥ng ƒë√∫ng. Tr·ª£ gi·∫£ng h√£y nh·∫≠p l·∫°i.`;

            await ZaloAPI.sendReaction(accessToken, zaloUserId, messageId, 'sad');

            await ZaloAPI.sendMessage(accessToken, zaloUserId, failContent);
        }
    }

    // Neu tu PHHS thi khong co hieu luc
    else {
        const warningMessage = 'T√≠nh nƒÉng t√≠nh nƒÉng n√†y ch·ªâ d√†nh cho t√†i kho·∫£n l√† tr·ª£ gi·∫£ng c·ªßa l·ªõp to√°n.';

        await ZaloAPI.sendMessage(accessToken, taZaloId, warningMessage);
    }
}

async function signUp(accessToken, zaloUserId, zaloColl, classColl, classInfoColl, formatContent, messageId, zaloRole) {
    // dkph 2004001 0123456789
    const TOTAL_REGISTER_SYNTAX = 21;
    const isValidRegisterSyntax = formatContent.length === TOTAL_REGISTER_SYNTAX;

    if (isValidRegisterSyntax) {
        const targetStudentId = parseInt(formatContent.substring(4, 11));

        const registerPhone = formatContent.slice(-10);

        const isExistInZaloColl = await MongoDB.findOneUser(
            zaloColl,
            { zaloUserId: `${zaloUserId}` },
            { projection: { _id: 0 } }
        );

        // Neu phu huynh chua co du lieu trong Zalo Coll
        // Neu nguoi dung quan tam lan dau
        if (isExistInZaloColl === null) {
            const profileDoc = await ZaloAPI.getProfile(accessToken, zaloUserId);

            await ZaloAPI.removeFollowerFromTag(accessToken, zaloUserId, 'Ch∆∞a quan t√¢m');

            await ZaloAPI.tagFollower(accessToken, zaloUserId, 'Ch∆∞a ƒëƒÉng k√≠');

            await MongoDB.insertOneUser(zaloColl, profileDoc);
        }

        const { userPhone, students, displayName } = isExistInZaloColl;

        // Kiem tra sdt dang ki co match voi so da ton tai hoac chua ton tai so nao
        const isNotYetRegister = userPhone === null;
        const isMatch = userPhone === registerPhone;
        const isNotMatch = userPhone !== registerPhone;

        // Neu chua tung dang ky bao gio (dang ki lan dau tien)
        if (isNotYetRegister) {
            let zaloStudentIdArr = [];
            let zaloClassIdArr = [];
            let aliasNameArr = [];

            // kiem tra tren class collection
            const classUserInfo = await MongoDB.findOneUser(
                classColl,
                { studentId: targetStudentId },
                { projection: { _id: 0 } }
            );

            const isExistStudentId = classUserInfo !== null;

            // Neu ton tai Id tren he thong
            if (isExistStudentId) {
                const { firstParentPhone, secondParentPhone, studentPhone, fullName, classId } = classUserInfo;

                let registerPhoneList;

                if (zaloRole === 'Ph·ª• huynh') {
                    registerPhoneList = [firstParentPhone, secondParentPhone];
                } else {
                    registerPhoneList = [studentPhone];
                }

                const isContainRegisterPhone = registerPhoneList.includes(registerPhone);

                // Neu sdt nam trong ds dang ki
                if (isContainRegisterPhone) {
                    // set up role cho zalo user
                    const classInfo = await MongoDB.findOneUser(
                        classInfoColl,
                        { classId: classId },
                        { projection: { _id: 0, className: 1 } }
                    );

                    const isExistClassInfo = classInfo !== null;

                    // Neu ton tai ma lop
                    if (isExistClassInfo) {
                        const { className } = classInfo;

                        const successContent = `‚úÖ ƒêƒÉng k√≠ th√†nh c√¥ng!\n\nZalo ${displayName} ƒë√£ ƒë∆∞·ª£c ƒëƒÉng k√≠ v·ªõi h·ªçc sinh ${fullName} c√≥ ID l√† ${targetStudentId} ·ªü l·ªõp ${className}.\n\n${zaloRole} ƒë√£ c√≥ th·ªÉ s·ª≠ d·ª•ng ƒë·∫ßy ƒë·ªß c√°c t√≠nh nƒÉng c·ªßa l·ªõp to√°n ·ªü m·ª•c ti·ªán √≠ch b√™n d∆∞·ªõi.`;

                        await ZaloAPI.sendReaction(accessToken, zaloUserId, messageId, 'heart');

                        await ZaloAPI.sendMessage(accessToken, zaloUserId, successContent);

                        const zaloRole2Short = {
                            'Ph·ª• huynh': 'PH',
                            'H·ªçc sinh': 'HS',
                        };

                        // them class id moi
                        zaloClassIdArr.push(classId);
                        // them id hs moi
                        zaloStudentIdArr.push(targetStudentId);
                        // them alias moi
                        aliasNameArr.push(`${zaloRole2Short[zaloRole]} ${fullName}`);

                        // Cap nhat tag tren Zalo OA Chat
                        ZaloAPI.tagFollower(accessToken, zaloUserId, zaloRole);
                        ZaloAPI.tagFollower(accessToken, zaloUserId, zaloClassIdArr.at(-1));
                        ZaloAPI.removeFollowerFromTag(accessToken, zaloUserId, 'Ch∆∞a ƒëƒÉng k√≠');
                        ZaloAPI.removeFollowerFromTag(accessToken, zaloUserId, 'Ch∆∞a quan t√¢m');

                        // cap nhat role cho PHHS trong Zalo Collection
                        MongoDB.updateOneUser(
                            zaloColl,
                            { zaloUserId: `${zaloUserId}` },
                            {
                                $set: {
                                    userPhone: `${registerPhone}`,
                                },
                                $push: {
                                    students: {
                                        zaloStudentId: targetStudentId,
                                        zaloClassId: classId,
                                        aliasName: `${zaloRole2Short[zaloRole]} ${fullName}`,
                                        role: zaloRole,
                                    },
                                },
                            }
                        );

                        return successContent;
                    }

                    // Neu ma lop chua ton tai
                    else {
                        const failContent = `‚ùå ƒêƒÉng k√≠ th·∫•t b·∫°i!\n\nL·ªõp ${classId} ch∆∞a ƒë∆∞·ª£c t·∫°o tr√™n h·ªá th·ªëng. ${zaloRole} h√£y li√™n h·ªá v·ªõi tr·ª£ gi·∫£ng ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£.`;

                        await ZaloAPI.sendReaction(accessToken, zaloUserId, messageId, 'sad');

                        await ZaloAPI.sendMessage(accessToken, zaloUserId, failContent);

                        return failContent;
                    }
                }
                // Neu khong nam trong ds dang ki
                else {
                    const failContent = `‚ùå ƒêƒÉng k√≠ th·∫•t b·∫°i!\n\nS·ªë ƒëi·ªán tho·∫°i ${registerPhone} ch∆∞a c√≥ trong danh s√°ch ƒë√£ ƒëƒÉng k√≠. ${zaloRole} h√£y li√™n h·ªá v·ªõi tr·ª£ gi·∫£ng ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£.`;

                    await ZaloAPI.sendReaction(accessToken, zaloUserId, messageId, 'sad');

                    await ZaloAPI.sendMessage(accessToken, zaloUserId, failContent);

                    return failContent;
                }
            }

            // Neu khong ton tai Id tren he thong
            else {
                const failContent = `‚ùå ƒêƒÉng k√≠ th·∫•t b·∫°i!\n\nID h·ªçc sinh ${targetStudentId} kh√¥ng t·ªìn t·∫°i tr√™n h·ªá th·ªëng. ${zaloRole} h√£y li√™n h·ªá v·ªõi tr·ª£ gi·∫£ng ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£.`;

                await ZaloAPI.sendReaction(accessToken, zaloUserId, messageId, 'sad');

                await ZaloAPI.sendMessage(accessToken, zaloUserId, failContent);

                return failContent;
            }
        }

        // Neu match voi sdt dki (dang ki them cho hs khac)
        else if (isMatch) {
            // Kiem tra sdt trong cu phap da duoc lien ket voi IDHS chua
            let linkStudentIdList = [];
            for (let i = 0; i < students.length; i++) {
                const { zaloStudentId } = students[i];

                linkStudentIdList.push(parseInt(zaloStudentId));
            }

            const isLinked = linkStudentIdList.includes(targetStudentId);

            // Neu da duoc lien ket
            if (isLinked) {
                const failContent = `‚≠ê Th√¥ng b√°o!\n\nS·ªë ƒëi·ªán tho·∫°i ${registerPhone} ƒë√£ ƒë∆∞·ª£c ƒëƒÉng k√≠ v·ªõi ID h·ªçc sinh ${targetStudentId}. Ph·ª• huynh kh√¥ng c·∫ßn ph·∫£i ƒëƒÉng k√≠ l·∫°i n·ªØa ·∫°.\n\n${zaloRole} l∆∞u √Ω:\nM·ªói t√†i kho·∫£n Zalo ch·ªâ ƒë∆∞·ª£c li√™n k·∫øt v·ªõi 1 s·ªë ƒëi·ªán tho·∫°i ƒë√£ ƒë∆∞·ª£c ƒëƒÉng k√≠ v·ªõi h·ªçc sinh tr∆∞·ªõc ƒë√≥. N·∫øu c√≥ nhu c·∫ßu chuy·ªÉn ƒë·ªïi t√†i kho·∫£n, ${zaloRole} vui l√≤ng li√™n h·ªá v·ªõi tr·ª£ gi·∫£ng ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£.`;

                await ZaloAPI.sendReaction(accessToken, zaloUserId, messageId, 'like');

                await ZaloAPI.sendMessage(accessToken, zaloUserId, failContent);

                return failContent;
            }

            // Neu sdt chua duoc lien ket voi hoc sinh nay
            else {
                let zaloStudentIdArr = [];
                let zaloClassIdArr = [];
                let aliasNameArr = [];

                // Neu sdt da dang ki voi 1 hoc sinh khac
                if (students.length > 0) {
                    students.forEach((v) => {
                        const { zaloStudentId, zaloClassId, aliasName } = v;
                        zaloStudentIdArr.push(zaloStudentId);
                        zaloClassIdArr.push(zaloClassId);
                        aliasNameArr.push(aliasName);
                    });
                }

                // kiem tra tren class collection
                const classUserInfo = await MongoDB.findOneUser(
                    classColl,
                    { studentId: targetStudentId },
                    { projection: { _id: 0 } }
                );

                const isExistStudentId = classUserInfo !== null;

                // Neu ton tai Id tren he thong
                if (isExistStudentId) {
                    const { firstParentPhone, secondParentPhone, studentPhone, fullName, classId } = classUserInfo;

                    let registerPhoneList;

                    if (zaloRole === 'Ph·ª• huynh') {
                        registerPhoneList = [firstParentPhone, secondParentPhone];
                    } else {
                        registerPhoneList = [studentPhone];
                    }

                    const isContainRegisterPhone = registerPhoneList.includes(registerPhone);

                    // Neu sdt nam trong ds dang ki
                    if (isContainRegisterPhone) {
                        // set up role cho zalo user
                        const classInfo = await MongoDB.findOneUser(
                            classInfoColl,
                            { classId: classId },
                            { projection: { _id: 0, className: 1 } }
                        );

                        const isExistClassInfo = classInfo !== null;

                        // Neu ton tai ma lop
                        if (isExistClassInfo) {
                            const { className } = classInfo;

                            const successContent = `‚úÖ ƒêƒÉng k√≠ th√†nh c√¥ng!\n\nZalo ${displayName} ƒë√£ ƒë∆∞·ª£c ƒëƒÉng k√≠ v·ªõi h·ªçc sinh ${fullName} c√≥ ID l√† ${targetStudentId} ·ªü l·ªõp ${className}.\n\n${zaloRole} ƒë√£ c√≥ th·ªÉ s·ª≠ d·ª•ng ƒë·∫ßy ƒë·ªß c√°c t√≠nh nƒÉng c·ªßa l·ªõp to√°n ·ªü m·ª•c ti·ªán √≠ch b√™n d∆∞·ªõi.`;

                            await ZaloAPI.sendReaction(accessToken, zaloUserId, messageId, 'heart');

                            await ZaloAPI.sendMessage(accessToken, zaloUserId, successContent);

                            const zaloRole2Short = {
                                'Ph·ª• huynh': 'PH',
                                'H·ªçc sinh': 'HS',
                            };

                            // them class id moi
                            zaloClassIdArr.push(classId);
                            // them id hs moi
                            zaloStudentIdArr.push(targetStudentId);
                            // them alias moi
                            aliasNameArr.push(`${zaloRole2Short[zaloRole]} ${fullName}`);

                            // Cap nhat tag tren Zalo OA Chat
                            ZaloAPI.tagFollower(accessToken, zaloUserId, zaloRole);
                            ZaloAPI.tagFollower(accessToken, zaloUserId, zaloClassIdArr.at(-1));
                            ZaloAPI.removeFollowerFromTag(accessToken, zaloUserId, 'Ch∆∞a ƒëƒÉng k√≠');
                            ZaloAPI.removeFollowerFromTag(accessToken, zaloUserId, 'Ch∆∞a quan t√¢m');

                            // cap nhat role cho PHHS trong Zalo Collection
                            MongoDB.updateOneUser(
                                zaloColl,
                                { zaloUserId: `${zaloUserId}` },
                                {
                                    $set: {
                                        userPhone: `${registerPhone}`,
                                    },
                                    $push: {
                                        students: {
                                            zaloStudentId: targetStudentId,
                                            zaloClassId: classId,
                                            aliasName: `${zaloRole2Short[zaloRole]} ${fullName}`,
                                            role: zaloRole,
                                        },
                                    },
                                }
                            );

                            return successContent;
                        }

                        // Neu ma lop chua ton tai
                        else {
                            const failContent = `‚ùå ƒêƒÉng k√≠ th·∫•t b·∫°i!\n\nL·ªõp ${classId} ch∆∞a ƒë∆∞·ª£c t·∫°o tr√™n h·ªá th·ªëng. ${zaloRole} h√£y li√™n h·ªá v·ªõi tr·ª£ gi·∫£ng ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£.`;

                            await ZaloAPI.sendReaction(accessToken, zaloUserId, messageId, 'sad');

                            await ZaloAPI.sendMessage(accessToken, zaloUserId, failContent);

                            return failContent;
                        }
                    }
                    // Neu khong nam trong ds dang ki
                    else {
                        const failContent = `‚ùå ƒêƒÉng k√≠ th·∫•t b·∫°i!\n\nS·ªë ƒëi·ªán tho·∫°i ${registerPhone} ch∆∞a c√≥ trong danh s√°ch ƒë√£ ƒëƒÉng k√≠. ${zaloRole} h√£y li√™n h·ªá v·ªõi tr·ª£ gi·∫£ng ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£.`;

                        await ZaloAPI.sendReaction(accessToken, zaloUserId, messageId, 'sad');

                        await ZaloAPI.sendMessage(accessToken, zaloUserId, failContent);

                        return failContent;
                    }
                }

                // Neu khong ton tai Id tren he thong
                else {
                    const failContent = `‚ùå ƒêƒÉng k√≠ th·∫•t b·∫°i!\n\nID h·ªçc sinh ${targetStudentId} kh√¥ng t·ªìn t·∫°i tr√™n h·ªá th·ªëng. ${zaloRole} h√£y li√™n h·ªá v·ªõi tr·ª£ gi·∫£ng ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£.`;

                    await ZaloAPI.sendReaction(accessToken, zaloUserId, messageId, 'sad');

                    await ZaloAPI.sendMessage(accessToken, zaloUserId, failContent);

                    return failContent;
                }
            }
        }

        // Neu khong match voi sdt dang ki (da co tai khoan khac dang ki Zalo nay roi)
        else if (isNotMatch) {
            const failContent = `‚≠ê Th√¥ng b√°o!\n\nƒê√£ c√≥ 1 s·ªë ƒëi·ªán tho·∫°i kh√°c ƒëƒÉng k√≠ v·ªõi t√†i kho·∫£n Zalo n√†y.\n\n${zaloRole} l∆∞u √Ω:\nM·ªói t√†i kho·∫£n Zalo ch·ªâ ƒë∆∞·ª£c li√™n k·∫øt v·ªõi 1 s·ªë ƒëi·ªán tho·∫°i ƒë√£ ƒë∆∞·ª£c ƒëƒÉng k√≠ v·ªõi h·ªçc sinh tr∆∞·ªõc ƒë√≥. N·∫øu c√≥ nhu c·∫ßu chuy·ªÉn ƒë·ªïi t√†i kho·∫£n, ${zaloRole} vui l√≤ng li√™n h·ªá v·ªõi tr·ª£ gi·∫£ng ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£.`;

            await ZaloAPI.sendReaction(accessToken, zaloUserId, messageId, 'like');

            await ZaloAPI.sendMessage(accessToken, zaloUserId, failContent);

            return failContent;
        }
    }

    // Neu sai cu phap dang ki tai khoan
    else {
        const failContent = `‚ùå ƒêƒÉng k√≠ th·∫•t b·∫°i!\n\nC√∫ ph√°p kh√¥ng ƒë√∫ng. M√£ ID h·ªçc sinh ph·∫£i g·ªìm 7 k√≠ t·ª± v√† s·ªë ƒëi·ªán tho·∫°i g·ªìm 10 s·ªë. ${zaloRole} h√£y ki·ªÉm tra v√† nh·∫≠p l·∫°i.`;

        await ZaloAPI.sendReaction(accessToken, zaloUserId, messageId, 'sad');

        await ZaloAPI.sendMessage(accessToken, zaloUserId, failContent);

        return failContent;
    }
}

export {
    sendUnfollow2Assistant,
    nomarlizeSyntax,
    signUp,
    isFollow,
    signUp4Assistant,
    forwardMessage2Assistant,
    isManagerCheck,
    sendMessageBack2Parent,
    sendMessage2Assistant,
    findZaloIdFromStudentId,
    sendReactBack2Parent,
    deleteAccount,
    notifyRegister,
    sendClassInfo,
    createDate,
    formatDate,
    formatDateTime,
    formatCurrency,
    removeVietNam,
    sendSyntaxPayment,
    sendPaymentTypeInfo,
    sendPaymentInfo,
    sendAttendanceInfo,
    signUpAlert,
    signUpRole,
    signUp4Parent,
    signUp4Student,
    forwardImage2Assistant,
    sendImageBack2Parent,
    sendAssistantInfo,
    getStudyDate,
    sendScoreInfo,
};
